t_taxonomy_table <- as.data.frame(t(taxonomy_table))
#Merge both tables <- only the rows in common are in the new table
t_filtered_taxonomy_table <- merge(filtered_taxonomy, t_taxonomy_table, by="row.names")
rownames(t_filtered_taxonomy_table) <- t_filtered_taxonomy_table[,1]
t_filtered_taxonomy_table <- t_filtered_taxonomy_table[,-1]
##Remove Mean column
t_filtered_taxonomy_table <- t_filtered_taxonomy_table[,-1]
##Transpose the matrix to get the filtered taxonomy table
filtered_taxonomy_table <- as.data.frame(t(t_filtered_taxonomy_table))
write.table(filtered_taxonomy_table, file="~/filtered_taxonomy.txt", sep = "\t", quote = F)
##Insterection plot
filtered_plot_data <- as.data.frame(setNames(replicate(2, numeric(0), simplify = F), letters[1:2]))
colnames(filtered_plot_data)[1:2] <- c("abundance","individuals")
##Add filter columns by abundance and individuals conditions
# 1 value: removed taxa
# 0 value: not removed taxa
for (i in 1:nrow(tax_parameters))  {
if (tax_parameters[i,"Mean"]<abundance_value) {
filtered_plot_data[i,"abundance"] <- 1
}
else {
# 1 value
filtered_plot_data[i,"abundance"] <- 0
}
if (tax_parameters[i,"N_of_non-0"]<individuals_value) {
filtered_plot_data[i,"individuals"] <- 1
}
else {
filtered_plot_data[i,"individuals"] <- 0
}
}
rownames(filtered_plot_data) <- rownames(tax_parameters)
##Add column: overlap between NOT removed taxa by both methods
filtered_plot_data$overlap <- "none"
##Add overlap column to color the plot with the intersection
for (i in 1:nrow(filtered_plot_data)) {
#If the taxa is NOT removed by the two methods
if (filtered_plot_data[i,"abundance"]==1 & filtered_plot_data[i,"individuals"]==1) {
#overlap column gets a random number between 20 and 40
filtered_plot_data[i, "overlap"] <- sample(20:40, 1)
}
else {
filtered_plot_data[i,"overlap"] <- 0
}
}
##Get rownames as a column to plot
filtered_plot_data <- cbind(Row.names = rownames(filtered_plot_data), filtered_plot_data)
rownames(filtered_plot_data) <- NULL
colnames(filtered_plot_data)[1] <- "Name"
library(UpSetR)
#Function to color the intersection in NOT removed taxonomies by both methods
yes <- function(row, min, max){
#Only count/color the taxa with overlap values
newData <- (row["overlap"] <= max) & (row["overlap"] >= min)
}
## Save the plot as pdf.file
pdf("intersection_filtering_plot.pdf")
##Intersection plot: marked in red the number of taxonomies removed by both methods
intersection_filtering_plot <- upset(filtered_plot_data, sets = c("abundance","individuals"), main.bar.color = "black", queries = list(list(query =intersects, params = list("abundance","individuals")), list( query=yes, params = list(20,40), color = "#528EE7", active = T)))
print(intersection_filtering_plot)
dev.off()
}
taxonomy_abundance(tax_table,0.01,15)
shannon_function <- function(level_table, group_table) {
##Required packages - shannon diversity/ggplot
library(vegan)
library(ggplot2)
## Calculate shannon (alpha) for each sample
alpha <- as.data.frame(diversity(level_table, index="shannon"))
colnames(alpha)[1] <- "alpha_diversity"
## Divide alpha results by intestinal groups
#Merge alpha with intestinal groups table
group_taxa <- merge(group_table, alpha, by="row.names")
rownames(group_taxa) <- group_taxa[,1]
group_taxa <- group_taxa[,-1]
#colnames(group_taxa)[2] <- "diversity"
# Create a new column to assign a number to each category
group_taxa$category <- as.integer(group_taxa[,1])
# Create a new column to colour the plot depending on the category (level)
group_taxa$color = "none"
# Create a palette of colors depending on the number of categories
my_palette <- matrix(brewer.pal(category_number,"Set1"))
# For loop to assign one different color to each different category in a new column
for (i in 1:category_number){
group_taxa[group_taxa$category == i,]$color = my_palette[i,1]
}
### Create a violin plot
shannon_plot <- ggplot(group_taxa, aes(x=category, y=alpha_diversity, fill = group_taxa$color)) + labs (y="Shannon Diversity Index", x="Category") + geom_violin(trim=FALSE) + geom_boxplot(width = 0.1) + theme_classic() + theme(legend.position="none") + theme(axis.text.x = element_text(hjust = 1, size=16,color="black")) + scale_color_identity("All_categories", breaks = group_taxa$color, labels= group_taxa$category, guide = "legend")
##Save the plots as pdf.file
pdf("shannon_plot.pdf")
print(shannon_plot)
dev.off()
}
shannon_function <- function(level_table, group_table) {
##Required packages - shannon diversity/ggplot
library(vegan)
library(ggplot2)
## Calculate shannon (alpha) for each sample
alpha <- as.data.frame(diversity(level_table, index="shannon"))
colnames(alpha)[1] <- "alpha_diversity"
## Divide alpha results by intestinal groups
#Merge alpha with intestinal groups table
group_taxa <- merge(group_table, alpha, by="row.names")
rownames(group_taxa) <- group_taxa[,1]
group_taxa <- group_taxa[,-1]
#colnames(group_taxa)[2] <- "diversity"
# Calculate the number of categories
category_number <- nlevels(group_taxa[,1])
# Create a new column to assign a number to each category
group_taxa$category <- as.integer(group_taxa[,1])
# Create a new column to colour the plot depending on the category (level)
group_taxa$color = "none"
# Create a palette of colors depending on the number of categories
my_palette <- matrix(brewer.pal(category_number,"Set1"))
# For loop to assign one different color to each different category in a new column
for (i in 1:category_number){
group_taxa[group_taxa$category == i,]$color = my_palette[i,1]
}
### Create a violin plot
shannon_plot <- ggplot(group_taxa, aes(x=category, y=alpha_diversity, fill = group_taxa$color)) + labs (y="Shannon Diversity Index", x="Category") + geom_violin(trim=FALSE) + geom_boxplot(width = 0.1) + theme_classic() + theme(legend.position="none") + theme(axis.text.x = element_text(hjust = 1, size=16,color="black")) + scale_color_identity("All_categories", breaks = group_taxa$color, labels= group_taxa$category, guide = "legend")
##Save the plots as pdf.file
pdf("shannon_plot.pdf")
print(shannon_plot)
dev.off()
}
species_table <- read.table("~/Documents/Universitat/Holanda/Projecte/Filtered_DUDes/species_table_DUDes.txt", sep = "\t", header = T, row.names = 1, check.names = F)
intestinal_groups <- read.table("~/Documents/Universitat/Holanda/Projecte/intestinal_groups.txt", sep = "\t", header = T, row.names = 1)
shannon_function(species_table, intestinal_groups)
taxonomy_abundance <- function(taxonomy_table,abundance_value,individuals_value) {
##Function to calculate mean excluding 0 values
nzmean <- function(a){
mean(a[a!=0])
}
##Function to calculate nº of 0
zsum <- function(a){
sum (a==0)
}
##Function to calculate nº of non-0
nsum <- function(a){
sum (a!=0)
}
my_results=matrix(ncol = 4, nrow=ncol(taxonomy_table))
## Loop for each column (taxonomy) in the taxonomy table
for (i in 1:ncol(taxonomy_table)) {
#Calculate mean for each column
aa = mean(taxonomy_table[,i])
#Calculate number of non-zeros (individuals)
bb = nsum(taxonomy_table[,i])
#Calculate mean without taking into account the 0
cc = nzmean(taxonomy_table[,i])
#Calculate number of zeros
dd = zsum(taxonomy_table[,i])
my_results[i,1] = aa
my_results[i,2] = bb
my_results[i,3] = cc
my_results[i,4] = dd
}
# The column names from the original table = row names from the new table
rownames(my_results) = colnames(taxonomy_table)
# Give names to the columns of the new table
colnames(my_results) = c("Mean","N_of_non-0", "Non-0_Mean", "N_of_0")
tax_parameters <- as.data.frame(my_results)
tax_parameters[is.na(tax_parameters)] <- 0
write.table(tax_parameters, file="~/summary_taxonomy_filtering.txt", sep = "\t", quote=F)
##Filtering by ABUNDANCE or N_OF_0
##Remove mean rows with less than 0.01% values OR less than 15 individuals (non_0)
filtered_taxonomy <- tax_parameters[!(tax_parameters$Mean<abundance_value) & !(tax_parameters$`N_of_non-0`<individuals_value), , FALSE]
#Remove non-necessary columns
filtered_taxonomy[2:4] <- NULL
##Transpose the taxonomy_table to merge
t_taxonomy_table <- as.data.frame(t(taxonomy_table))
#Merge both tables <- only the rows in common are in the new table
t_filtered_taxonomy_table <- merge(filtered_taxonomy, t_taxonomy_table, by="row.names")
rownames(t_filtered_taxonomy_table) <- t_filtered_taxonomy_table[,1]
t_filtered_taxonomy_table <- t_filtered_taxonomy_table[,-1]
##Remove Mean column
t_filtered_taxonomy_table <- t_filtered_taxonomy_table[,-1]
##Transpose the matrix to get the filtered taxonomy table
filtered_taxonomy_table <- as.data.frame(t(t_filtered_taxonomy_table))
write.table(filtered_taxonomy_table, file="~/filtered_taxonomy.txt", sep = "\t", quote = F)
##Insterection plot
filtered_plot_data <- as.data.frame(setNames(replicate(2, numeric(0), simplify = F), letters[1:2]))
colnames(filtered_plot_data)[1:2] <- c("abundance","individuals")
##Add filter columns by abundance and individuals conditions
# 1 value: removed taxa
# 0 value: not removed taxa
for (i in 1:nrow(tax_parameters))  {
if (tax_parameters[i,"Mean"]<abundance_value) {
filtered_plot_data[i,"abundance"] <- 1
}
else {
# 1 value
filtered_plot_data[i,"abundance"] <- 0
}
if (tax_parameters[i,"N_of_non-0"]<individuals_value) {
filtered_plot_data[i,"individuals"] <- 1
}
else {
filtered_plot_data[i,"individuals"] <- 0
}
}
rownames(filtered_plot_data) <- rownames(tax_parameters)
##Add column: overlap between NOT removed taxa by both methods
filtered_plot_data$overlap <- "none"
##Add overlap column to color the plot with the intersection
for (i in 1:nrow(filtered_plot_data)) {
#If the taxa is NOT removed by the two methods
if (filtered_plot_data[i,"abundance"]==1 & filtered_plot_data[i,"individuals"]==1) {
#overlap column gets a random number between 20 and 40
filtered_plot_data[i, "overlap"] <- sample(20:40, 1)
}
else {
filtered_plot_data[i,"overlap"] <- 0
}
}
##Get rownames as a column to plot
filtered_plot_data <- cbind(Row.names = rownames(filtered_plot_data), filtered_plot_data)
rownames(filtered_plot_data) <- NULL
colnames(filtered_plot_data)[1] <- "Name"
library(UpSetR)
#Function to color the intersection in NOT removed taxonomies by both methods
yes <- function(row, min, max){
#Only count/color the taxa with overlap values
newData <- (row["overlap"] <= max) & (row["overlap"] >= min)
}
## Save the plot as pdf.file
pdf("intersection_filtering_plot.pdf")
##Intersection plot: marked in red the number of taxonomies removed by both methods
intersection_filtering_plot <- upset(filtered_plot_data, sets = c("abundance","individuals"), main.bar.color = "black", queries = list(list(query =intersects, params = list("abundance","individuals")), list( query=yes, params = list(20,40), color = "#528EE7", active = T)))
print(intersection_filtering_plot)
dev.off()
}
taxonomy_abundance(tax_table,0.01,15)
source("functions_script.R")
setwd("~/Documents/Universitat/Holanda/Projecte/Scripts/Function Scripts/")
source("functions_script.R")
source("functions_script.R")
tax_table <- read.table("~/Documents/Universitat/Holanda/Projecte/filtered_tax_DUDes.txt", sep = "\t", header = T, row.names = 1, check.names = F)
level_function(tax_table, 5)
install.packages(PresenceAbsence)
install.packages("PresenceAbsence")
library(PresenceAbsence)
data("SPDATA")
View(SPDATA)
species <- as.character(unique(SPDATA$SPECIES))
model.names <- as.character(names(SPDATA)[-c(1, 2)])
N.models <- ncol(SPDATA) - 2
N.sp <- length(species)
N.obs <- length(SPDATA$SPECIES[SPDATA$SPECIES == species[1]])
Obs.prev <- table(SPDATA$SPECIES, SPDATA$OBSERVED)[, 2]/N.obs
Obs.prev
Obs.prev <- round(Obs.prev, digits = 2)
par(oma = c(0, 0, 3, 0), mar = c(4, 4, 4, 1), mfrow = c(1, 3), cex = 1)
sp <- 1
DATA <- SPDATA[SPDATA$SPECIES == species[sp], ]
View(DATA)
for (mod in 1:N.models) {
presence.absence.hist(DATA, which.model = mod, legend.cex = 1, N.bars = 20)
}
mtext(species[sp], side = 3, line = 0.5, cex = 1.5, outer = TRUE)
dev.off()
par(oma = c(0, 0, 3, 0), mar = c(4, 4, 4, 1), mfrow = c(1, 3), cex = 1)
sp <- 1
DATA <- SPDATA[SPDATA$SPECIES == species[sp], ]
for (mod in 1:N.models) {
presence.absence.hist(DATA, which.model = mod, legend.cex = 1, N.bars = 20)
}
mtext(species[sp], side = 3, line = 0.5, cex = 1.5, outer = TRUE)
presence.absence.hist(DATA, which.model = 1, legend.cex = 1, N.bars = 20)
aa <- presence.absence.hist(DATA, which.model = 1, legend.cex = 1, N.bars = 20)
aa
DATA <- SPDATA[SPDATA$SPECIES == species[sp], ]
library(PresenceAbsence)
data("SPDATA")
species <- as.character(unique(SPDATA$SPECIES))
model.names <- as.character(names(SPDATA)[-c(1, 2)])
N.models <- ncol(SPDATA) - 2
N.sp <- length(species)
N.obs <- length(SPDATA$SPECIES[SPDATA$SPECIES == species[1]])
Obs.prev <- table(SPDATA$SPECIES, SPDATA$OBSERVED)[, 2]/N.obs
par(oma = c(0, 0, 3, 0), mar = c(4, 4, 4, 1), mfrow = c(1, 3), cex = 1)
sp <- 1
DATA <- SPDATA[SPDATA$SPECIES == species[sp], ]
for (mod in 1:N.models) {
presence.absence.hist(DATA, which.model = mod, legend.cex = 1, N.bars = 20)
}
mtext(species[sp], side = 3, line = 0.5, cex = 1.5, outer = TRUE)
install.packages("RVAideMemoire")
library(RVAideMemoire)
response <- c(0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,1)
fact <- gl(3,1,30,labels=LETTERS[1:3])
block <- gl(10,3,labels=letters[1:10])
response
fact
block
cochran.qtest(response~fact|block)
filum_table <- read.table("~/Documents/Universitat/Holanda/Projecte/Filtered_DUDes/filum_table_DUDes.txt", sep = "\t", header = T, row.names = 1, check.names = F)
groups <- read.table("~/Documents/Universitat/Holanda/Projecte/intestinal_groups.txt", sep = "\t", header = T, row.names = 1, check.names = F)
filum_table <- read.table("~/Documents/Universitat/Holanda/Projecte/Filtered_DUDes/filum_table_DUDes.txt", sep = "\t", header = T, row.names = 1, check.names = F)
groups <- read.table("~/Documents/Universitat/Holanda/Projecte/intestinal_groups.txt", sep = "\t", header = T, row.names = 1, check.names = F)
t_filum_table <- as.data.frame(t(filum_table))
p_a_table <- t_filum_table
for (i in 1:ncol(t_filum_table)) {
for (j in 1:nrow(t_filum_table)) {
if (t_filum_table[j,i]>0) {
p_a_table[j,i] = 1
}
}
}
group_pa_table <- merge(p_a_table, groups, by = "row.names")
rownames(group_pa_table) <- group_pa_table[,1]
group_pa_table <- group_pa_table[,-1]
normal_pa <- subset(group_pa_table, group_pa_table$Group =="normal")
intermediate_pa <- subset(group_pa_table, group_pa_table$Group=="intermediate")
small_pa <- subset(group_pa_table, group_pa_table$Group=="small intestine")
normal_pa$Group <- NULL
intermediate_pa$Group <- NULL
small_pa$Group <- NULL
mean_table <- matrix(nrow=3, ncol = ncol(normal_pa))
for (x in 1:ncol(small_pa)) {
a = mean(small_pa[,x])
mean_table[3,x] = a
}
View(mean_table)
mean_table <- matrix(nrow=3, ncol = ncol(normal_pa))
for (x in 1:ncol(normal_pa)) {
a = mean(normal_pa[,x])
mean_table[1,x] = a
}
View(mean_table)
View(groups)
filum_table <- read.table("~/Documents/Universitat/Holanda/Projecte/Filtered_DUDes/filum_table_DUDes.txt", sep = "\t", header = T, row.names = 1, check.names = F)
groups <- read.table("~/Documents/Universitat/Holanda/Projecte/intestinal_groups.txt", sep = "\t", header = T, row.names = 1, check.names = F)
p_a_table <- filum_table
p_a_table <- filum_table
for (i in 1:ncol(filum_table)) {
for (j in 1:nrow(filum_table)) {
if (filum_table[j,i]>0) {
p_a_table[j,i] = 1
}
}
}
View(p_a_table)
group_pa_table <- merge(p_a_table, groups, by = "row.names")
View(group_pa_table)
rownames(group_pa_table) <- group_pa_table[,1]
group_pa_table <- group_pa_table[,-1]
normal_pa <- subset(group_pa_table, group_pa_table$Group =="normal")
intermediate_pa <- subset(group_pa_table, group_pa_table$Group=="intermediate")
small_pa <- subset(group_pa_table, group_pa_table$Group=="small intestine")
normal_pa$Group <- NULL
intermediate_pa$Group <- NULL
small_pa$Group <- NULL
mean_table <- matrix(nrow=3, ncol = ncol(normal_pa))
for (x in 1:ncol(normal_pa)) {
a = mean(normal_pa[,x])
mean_table[1,x] = a
}
View(mean_table)
View(p_a_table)
for (x in 1:ncol(intermediate_pa)) {
a = mean(intermediate_pa[,x])
mean_table[2,x] = a
}
View(mean_table)
for (x in 1:ncol(small_pa)) {
a = mean(small_pa[,x])
mean_table[2,x] = a
}
mean_table <- as.data.frame(mean_table)
View(mean_table)
for (x in 1:ncol(intermediate_pa)) {
a = mean(intermediate_pa[,x])
mean_table[2,x] = a
}
for (x in 1:ncol(small_pa)) {
a = mean(small_pa[,x])
mean_table[3,x] = a
}
View(mean_table)
rownames(mean_table) = c("mean_normal", "mean_intermediate", "mean_small")
colnames(mean_table) = colnames(normal_pa)
abundance_taxonomy <- read.table("~/Documents/Universitat/Holanda/Projecte/Filtered_DUDes/relative_abundance_per_groups_DUDes.txt", sep = "\t", header = T, row.names = 1, check.names = F)
View(abundance_taxonomy)
View(intermediate_pa)
sum_table <- matrix(ncol = ncol(normal_pa), nrow=3)
for (i in 1:ncol(normal_pa)){
a = sum(normal_pa[,i])
sum_table[1,i] <- a
}
View(sum_table)
for (i in 1:ncol(small_pa)){
a = sum(small_pa[,i])
sum_table[3,i] <- a
}
View(sum_table)
for (i in 1:ncol(intermediate_pa)){
a = sum(intermediate_pa[,i])
sum_table[2,i] <- a
}
View(sum_table)
rownames(sum_table) <- c("normal", "intermediate", "small_intestine")
colnames(sum_table) <- colnames(normal_pa)
View(sum_table)
View(normal_pa)
tax_table <- read.table("~/Documents/Universitat/Holanda/Projecte/filtered_tax_DUDes.txt", sep = "\t", header = T, row.names = 1, check.names = F)
View(tax_table)
taxonomy_abundance <- function(taxonomy_table,abundance_value,individuals_value) {
##Function to calculate mean excluding 0 values
nzmean <- function(a){
mean(a[a!=0])
}
##Function to calculate nº of 0
zsum <- function(a){
sum (a==0)
}
##Function to calculate nº of non-0
nsum <- function(a){
sum (a!=0)
}
my_results=matrix(ncol = 4, nrow=ncol(taxonomy_table))
## Loop for each column (taxonomy) in the taxonomy table
for (i in 1:ncol(taxonomy_table)) {
#Calculate mean for each column
aa = mean(taxonomy_table[,i])
#Calculate number of non-zeros (individuals)
bb = nsum(taxonomy_table[,i])
#Calculate mean without taking into account the 0
cc = nzmean(taxonomy_table[,i])
#Calculate number of zeros
dd = zsum(taxonomy_table[,i])
my_results[i,1] = aa
my_results[i,2] = bb
my_results[i,3] = cc
my_results[i,4] = dd
}
# The column names from the original table = row names from the new table
rownames(my_results) = colnames(taxonomy_table)
# Give names to the columns of the new table
colnames(my_results) = c("Mean","N_of_non-0", "Non-0_Mean", "N_of_0")
tax_parameters <- as.data.frame(my_results)
tax_parameters[is.na(tax_parameters)] <- 0
write.table(tax_parameters, file="~/summary_taxonomy_filtering.txt", sep = "\t", quote=F)
##Filtering by ABUNDANCE or N_OF_0
##Remove mean rows with less than 0.01% values OR less than 15 individuals (non_0)
filtered_taxonomy <- tax_parameters[!(tax_parameters$Mean<abundance_value) & !(tax_parameters$`N_of_non-0`<individuals_value), , FALSE]
#Remove non-necessary columns
filtered_taxonomy[2:4] <- NULL
##Transpose the taxonomy_table to merge
t_taxonomy_table <- as.data.frame(t(taxonomy_table))
#Merge both tables <- only the rows in common are in the new table
t_filtered_taxonomy_table <- merge(filtered_taxonomy, t_taxonomy_table, by="row.names")
rownames(t_filtered_taxonomy_table) <- t_filtered_taxonomy_table[,1]
t_filtered_taxonomy_table <- t_filtered_taxonomy_table[,-1]
##Remove Mean column
t_filtered_taxonomy_table <- t_filtered_taxonomy_table[,-1]
##Transpose the matrix to get the filtered taxonomy table
filtered_taxonomy_table <- as.data.frame(t(t_filtered_taxonomy_table))
write.table(filtered_taxonomy_table, file="~/filtered_taxonomy.txt", sep = "\t", quote = F)
##Insterection plot
filtered_plot_data <- as.data.frame(setNames(replicate(2, numeric(0), simplify = F), letters[1:2]))
colnames(filtered_plot_data)[1:2] <- c("abundance","individuals")
##Add filter columns by abundance and individuals conditions
# 1 value: removed taxa
# 0 value: not removed taxa
for (i in 1:nrow(tax_parameters))  {
if (tax_parameters[i,"Mean"]<abundance_value) {
filtered_plot_data[i,"abundance"] <- 1
}
else {
# 1 value
filtered_plot_data[i,"abundance"] <- 0
}
if (tax_parameters[i,"N_of_non-0"]<individuals_value) {
filtered_plot_data[i,"individuals"] <- 1
}
else {
filtered_plot_data[i,"individuals"] <- 0
}
}
rownames(filtered_plot_data) <- rownames(tax_parameters)
##Add column: overlap between NOT removed taxa by both methods
filtered_plot_data$overlap <- "none"
##Add overlap column to color the plot with the intersection
for (i in 1:nrow(filtered_plot_data)) {
#If the taxa is NOT removed by the two methods
if (filtered_plot_data[i,"abundance"]==1 & filtered_plot_data[i,"individuals"]==1) {
#overlap column gets a random number between 20 and 40
filtered_plot_data[i, "overlap"] <- sample(20:40, 1)
}
else {
filtered_plot_data[i,"overlap"] <- 0
}
}
##Get rownames as a column to plot
filtered_plot_data <- cbind(Row.names = rownames(filtered_plot_data), filtered_plot_data)
rownames(filtered_plot_data) <- NULL
colnames(filtered_plot_data)[1] <- "Name"
library(UpSetR)
#Function to color the intersection in NOT removed taxonomies by both methods
yes <- function(row, min, max){
#Only count/color the taxa with overlap values
newData <- (row["overlap"] <= max) & (row["overlap"] >= min)
}
## Save the plot as pdf.file
pdf("intersection_filtering_plot.pdf")
##Intersection plot: marked in red the number of taxonomies removed by both methods
intersection_filtering_plot <- upset(filtered_plot_data, sets = c("abundance","individuals"), main.bar.color = "black", queries = list(list(query =intersects, params = list("abundance","individuals")), list( query=yes, params = list(20,40), color = "#528EE7", active = T)))
print(intersection_filtering_plot)
dev.off()
}
taxonomy_abundance(tax_table,0.01,15)
